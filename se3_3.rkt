#lang racket

;1.1
;TODO
(define tabelle '((#\A "Alfa")
                  (#\B "Bravo")
                  (#\C "Charlie")
                  (#\D "Delta")
                  (#\E "Echo")
                  (#\F "Foxtrott")
                  (#\G "Golf")
                  (#\H "Hotel")
                  (#\I "India")
                  (#\J "Juliett")
                  (#\K "Kilo")
                  (#\L "Lima")
                  (#\M "Mike")
                  (#\N "November")
                  (#\O "Oscar")
                  (#\P "Papa")
                  (#\Q "Quebec")
                  (#\R "Romeo")
                  (#\S "Sierra")
                  (#\T "Tango")
                  (#\U "Uniform")
                  (#\V "Viktor")
                  (#\W "Wiskey")
                  (#\X "X-ray")
                  (#\Y "Yankee")
                  (#\Z "Zulu")
                  (#\0 "Nadazero")
                  (#\1 "Unaone")
                  (#\2 "Bissotwo")
                  (#\3 "Terrathree")
                  (#\4 "Kartefour")
                  (#\5 "Pantafive")
                  (#\6 "Socisix")
                  (#\7 "Setteseven")
                  (#\8 "Oktoeight")
                  (#\9 "Novenine")
                  (#\, "Decimal")
                  (#\. "Stop")))

;1.2
(define (translate v dict)
  (let ((r (assoc v dict)))
    (cond ((not (equal? r #f)) (cdr r)))))

(define (Text->p text tabelle)
  (t->p (string->list text) tabelle '()))
(define (t->p liste tab ergebnis)
  (cond ((empty? liste) ergebnis)
        (else (cons (tabellenSurch (car liste) tabelle) ergebnis))))
(define (tabellenSurchAll surch tabelle ergebnisListe)
  (cond ((empty? tabelle) ergebnisListe)
        ((equal? surch (caar tabelle)) (tabellenSurch surch (cdr tabelle) (cons (cdar tabelle) ergebnisListe)))
        (else (tabellenSurch surch (cdr tabelle) ergebnisListe))))
(define (tabellenSurch surch tabelle)
  (cond ((empty? tabelle) null)
        ((equal? surch (caar tabelle)) (cons (cdar tabelle) '()))
        (else (tabellenSurch surch (cdr tabelle)))))

;1.3
(define (UP chr)
  (char-upcase chr))

;1.4
(define (Buchstabieren-eines-Textes text)
  (BeT (string->list (string-upcase text)) tabelle '()))
(define (transE v dict)
  (let ((r (translate v dict)))
    (cond ((void? r) '())
          (else  r))))
(define (BeT textList dict res)
  (cond ((empty? textList) res)
        (else (BeT (cdr textList) dict (append res (transE (car textList) dict))))))